#### 对面向对象的理解
面向对象注重有哪些参与者（对象），需要做什么（行为），更易于复用、扩展和维护
三大基本特征：
1. 封装， 隐藏类的成员变量和实现细节，不允许外部直接访问。（例如使用mybatis，操作数据库时，我们不需要关心链接是如何建立的、sql是如何执行的）
2. 继承，代码共享，减少创建类的工作量，每个子类都拥有父类非私有的方法和属性，提高了代码的复用
3. 多态，需要有继承关系，需要有方法的重写，需要有父类引用指向子类对象


#### JDK JRE JVM 联系
JDK：Java Develpment Kit ， java 开发工具
JRE：Java Runtime Environment，java运行时环境
JVM：Java Virtual Machine， java 虚拟机
![[0(1J(H8`IY`@ZIH745E(Y29.png]]


#### == 与 equals 比较
== : 2者比较的是栈中的值，那么基本数据类型判断的是变量值，而引用类型判断的是堆中内存对象的地址
equals:  Object 中默认采用== 比较，通常我们会重写，比如说String类型的equals比较(源代码本质上就比较2个字符的内容是否完全相同)。
```java
public boolean equals(Object obj) { 
	return (this == obj);
}
```

#### 8种数据结构
4种线性数据结构：数组，链表，栈，队列
4种非线性数据结构：树，堆，哈希表，图

#### String，StringBuffer，StringBuilder 区别和使用场景
1. String 是final修饰的，不可变，每次操作都会产生新的String对象。
	StringBuffer和StringBuilder，可变，都是在原对象上操作的。
2. StringBuffer是线程安全的，其方法都是synchronized修饰
	StringBuilder是线程不安全的
性能 ： StringBuilder > StringBuffer > String

场景 : 经常需要变更字符串时使用StringBuffer，StringBuilder 。
整体上优先使用StringBuilder ， 在多线程使用共享变量时使用StringBuffer。

#### static关键字
一句话概括用途：方便在没有创建对象的情况下来进行调用（方法/变量）。

1. 定义：表明一个成员变量或者成员方法可以在所属类没有实例对象的情况下被访问
2. 作用：
	- 为某特定的数据类型或对象分配单一的存储空间，而与创建对象的个数无关
	- 实现某个方法或属性与类而不是对象关联在一起
	- 注意：Java类提供了两种类型的变量：用static关键字修饰的静态变量和不用static关键字修饰的实例变量。
	   静态变量属于类，在内存中只有一个复制，只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了。对静态变量的引用有两种方式，分别是“类.静态变量"和”对象.静态变量"。
	   实例变量属于对象，只有对象被创建后，实例变量才会被分配内存空间，才能被使用，它在内存中存在多个复制，只有用“对象.实例变量”的方式来引用。

3.  static修饰的方法不能被重写，因为static方法是编译时静态绑定的，而方法覆盖是基于运行时动态绑定的。

4.  static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员和静态方法。（因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，static方法也不能访问非static类型的变量。）


#### final关键字的作用
- 修饰类：表示类不可被继承。
- 修饰方法：表示方法不可被子类重写，但是可以重载。
- 修饰变量：表示变量一经赋值就不可以更改它的值
- 修饰成员变量：
	1. 修饰的是类变量，只能在静态初始化块中指定初始值
	2. 修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值 
- 修饰局部变量：系统不会为局部变量进行初始化，必须由我们显示地初始化。 既可以定义时指定默认值，也可以不指定默认值，后面代码中在对final变量赋初值（仅一次）
- 修饰基本数据类型：其数值⼀旦在初始化之后便不能更改 
- 修饰引用数据类型：对其初始化之后便不能再让其指向另⼀个对象。但是引⽤的值是可变的

#### Java容器有哪些
![[Pasted image 20220922201941.png]]

#### List 和 Set的区别
List：有序，按对象进⼊的顺序保存对象，可重复，允许多个Null元素对象，可以使⽤Iterator取出所有元素，在逐⼀遍历，还可以使⽤get(int index)获取指定下标的元素

Set：⽆序，不可重复，最多允许有⼀个Null元素对象，取元素时只能⽤Iterator接⼝取得所有元素，在逐⼀遍历各个元素

#### ArrayList和LinkedList区别
1. ⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的 
2. 由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合 删除和添加 
3. ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以LinkedList还可以当做队列来使⽤


#### ArrayList 和Vector区别和扩容机制
ArrayList 和Vector,底层都是Object数组，默认加载因子都是1（元素满了才扩展容量）。默认容量都是10；但是ArrayList 在jdk1.8时默认为空，当添加元素时，才初始化为10个容量。ArrayList：新容量为原容量的1.5倍，Vector:新容量为原容量的2倍.
 
ArrayList 线程不安全，查询速度快； Vector线程安全，但速度慢


#### HashMap和HashTable有什么区别？其底层实现是什么？

区别 ：
1. HashMap⽅法没有synchronized修饰，线程⾮安全，HashTable线程安全；
2. HashMap允许key和value为null，⽽HashTable不允许

HashMap底层实现：数组+链表实现，jdk8开始链表⾼度到8、数组⻓度超过64，链表转变为红⿊树，元素以内部类Node节点存在

1. 计算key的hash值，⼆次hash然后对数组⻓度取模，对应到数组下标，

2. 如果没有产⽣hash冲突(下标位置没有元素)，则直接创建Node存⼊数组，

3. 如果产⽣hash冲突，先进⾏equal⽐较，相同则取代该元素，不同，则判断链表⾼度插⼊链表，链表⾼度达到8，并且数组⻓度到64则转变为红⿊树，⻓度低于6则将红⿊树转回链表

4. key为null，存在下标0的位置

#### Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)?
1. 1.7中底层是数组+链表，1.8中底层是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和查询整体效率

2. 1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法

3. 1.7中哈希算法⽐较复杂，存在各种右移与异或运算，1.8中进⾏了简化，因为复杂的哈希算法的⽬的就是提⾼散列性，来提供HashMap的整体效率，⽽1.8中新增了红⿊树，所以可以适当的简化哈希算法，节省CPU资源


#### CopyOnWriteArrayList的底层原理是怎样的
1. ⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏

2. 并且，写操作会加锁，防⽌出现并发写⼊丢失数据的问题

3. 写操作结束之后会把原数组指向新数组

4. CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应⽤场景，但是CopyOnWriteArrayList会⽐较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很⾼的场景

#### 重载和重写的区别
- 重载（Overload）
	1. 发⽣在同⼀个类中，⽅法名必须相同
	2. 参数列表不同包括：参数类型不同、参数个数不同、参数顺序不同
	3. ⽅法返回值和访问修饰符可以不同，发⽣在编译时
- 重写，又叫覆盖（Override）
	1. 发生在父子类中，
	2. 重写时保证方法名、参数列表、返回类型都相同，而方法体不同。
	3. 返回值范围⼩于等于⽗类，抛出的异常范围⼩于等于⽗类，访问修饰符范围⼤于等于⽗类
	4. 如果⽗类⽅法访问修饰符为private则⼦类就不能重写该⽅法，因为private修饰的方法只能在当前类使用，其他类继承了该类，连访问的权限都没有，更不别说方法覆盖了。

#### hashCode()和equals()的区别
1. 两者定义：
hashCode()：获取哈希码（又叫散列码，返回的是一个整数），而equals()：比较两个对象是否相等
2. 两者关系：
- 如果两个对象相等，则hashcode()值一定相等。
- 如果两个对象有相同的hashcode（）值，但他们不一定是相同的。
- 如果两个对象不equals()，它们的hashcode()有可能相等
- 若equals（）方法被重写了，那么hashcode（）方法也必须重写
- hashcode（）方法的默认行为是对堆上的对象产生独特值，若没有重写hashcode（），则该class的两个对象无论如何都不会相等（即使这2个对象指向了相同的数据）

#### 什么是字节码？采⽤字节码的好处是什么？
Java中的编译器和解释器：Java中引⼊了虚拟机的概念，即在机器和编译程序之间加⼊了⼀层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序⼀个的共同的接⼝。编译程序只需要⾯向虚拟机，⽣成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执⾏。在Java中，这种供虚拟机理解的代码叫做 字节码（即扩展名为 .class的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。

采⽤字节码的好处：Java语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问
题，同时⼜保留了解释型语⾔可移植的特点。所以Java程序运⾏时⽐较⾼效，⽽且，由于字节码并不专
对⼀种特定的机器，因此，Java程序⽆须重新编译便可在多种不同的计算机上运⾏。（1. 效率高 ，2. 可移植，3. 跨平台 ）

#### Java的异常体系
- Throwable是异常的顶层父类
- Throwable下有2个子类Exception和Error
- Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行
- Exception不会导致程序停止，它又有2个子类RunTimeException运行时异常 和 CheckedException检查异常
- RunTimeException发生在程序运行过程中，会导致程序当前线程执行失败
- CheckedException发生在程序编译过程中，会导致程序编译不通过

#### 反射的理解
反射就是指程序运行期间动态的获取对象的属性和方法的功能。它能够在程序运行期间，对于任意一个类，都能知道它所有的方法和属性，对于任意一个对象，都能知道他的属性和方法。

获取Class对象的三种方式：
1. xx.getClass();
2. xx.class;
3. Class.forName("xxx"); 

优点：运行期间能够动态的获取类，提高代码的灵活性。
缺点：性能比直接的Java代码要慢很多。 
应用场景：spring的xml配置模式，以及动态代理模式都用到了反射。

#### 接口和抽象类的区别
- 抽象类可以存在普通成员函数，而接口中只能存在public abstract方法（JDK8及以后，允许我们在接口中定义static方法和default方法）
- 抽象类中的成员变量可以任意，而接口中的成员变量只能是public static final来修饰的，并且完成初始化。
- 抽象类只能继承(extends)一个，而接口可以实现(implements)多个

接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有 什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，  但不对如何实现行为进行限制。

而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实 现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己  实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。

抽象类是对类本质的抽象，表达的是 is a 的关系，比如： BMW is a Car 。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。

而接口是对行为的抽象，表达的是 like a 的关系。比如： Bird like a Aircraft （像飞行器一样可以飞），但其本质上 is a Bird 。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

使用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也     是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功  能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度.


#### Java基本数据类型和引用类型
8种基本数据类型 ： 4种整数类型(byte 8位 ，short 16位，int 32位，long 64位)，2种浮点类型（float  32位，double 64位），布尔型 boolean，字符型 char， 8种基本数据类型声明后会立刻在栈上分配内存空间 。

其他类型都是引用类型：类，接口，数组，String等，这些变量在声明时不会被分配内存空间，只是存储了一个内存地址。

#### Java四类引用类型
1. 强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用，对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的。因此强引用是造成 Java 内存泄漏的主要原因之一。
2. 弱引用，需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只  要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
3. 软引用，需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回  收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
4. 虚引用，需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要  作用是跟踪对象被垃圾回收的状态。

#### Java内存泄露
内存泄漏，指不再会被使用的对象或者变量占用的内存不能被回收。

#### 深拷贝和浅拷贝
深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实例对象的引⽤。
1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象
2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制，深拷⻉出来的对象，内部的属性指向的不是同⼀个对象


#### throw 和 throws 的区别
throw是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。


#### 访问修饰符
Java中的访问修饰符有四种：
1. private，类中被private修饰的只能在被当前类的内部访问
2. default，类中被default修饰的只能在当前类和当前类所在包的其他类访问。
3. protected，类中被protected修饰的可以被当前类和当前类所在的包的其他类以及子类访问
4. public，类中被public修饰的能被当前项目下的所有类访问。

修饰范围：public>protected>default>private
public，default，private都可以用于修饰类，方法，变量。而protected不能用于修饰类。

#### 迭代器 Iterator 是什么
迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。

#### Iterator 和 ListIterator 有什么区别？
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。  Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。  
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

#### 线程的创建方式
1. 继承Thread类，重写run()方法
2. 实现Runnable接口，并实现该接口的run()方法
3. 实现Callable接口，重写call()方法
4. 使用线程池

#### JVM双亲委派模型
JVM中存在三个默认的类加载器：
1. BootstrapClassLoader ，是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件
2. ExtClassLoader ，是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和class 类
3. AppClassLoader ，是自定义类加载器的父类，负责加载classpath下的类文件。系统类加载器，线程上下文加载器


**自定义类加载器需要通过继承ClassLoader来实现**

![[Pasted image 20220922163936.png]]

好处：
1. 主要是为了安全性，避免用户自己编写的类动态替换 Java的一些核心类，比如 String。

2. 同时也避免了类的重复加载，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不同的 ClassLoader加载就是不同的两个类


#### GC（Garbage Collection，垃圾回收器）如何判断对象可以被回收
1. 引⽤计数法：每个对象有⼀个引⽤计数属性，新增⼀个引⽤时计数加1，引⽤释放时计数减1，计数为0时可以回收 （**可能会出现，A和B相互引用，循环引用无法回收情况，早期JDK使用方式**）
2. 可达性分析法：从 GC Roots 开始向下搜索，搜索所⾛过的路径称为引⽤链。当⼀个对象到 GC Roots时 没有任何引⽤链相连时，则证明此对象是不可⽤的，那么虚拟机就判断是可回收对象。

GC Roots的对象有：
- 虚拟机栈(栈帧中的本地变量表）中引⽤的对象
- ⽅法区中类静态属性引⽤的对象
- ⽅法区中常量引⽤的对象
- 本地⽅法栈中引⽤的对象

可达性算法中的不可达对象并不是⽴即死亡的，对象拥有⼀次⾃我拯救的机会。对象被系统宣告死亡⾄少要经历两次标记过程：第⼀次是经过可达性分析发现没有与GC Roots相连接的引⽤链，第⼆次是在由虚拟机⾃动建⽴的Finalizer队列中判断是否需要执⾏finalize()⽅法。

当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize⽅法，若未覆盖，则直接将其回收。否则，若对象未执⾏过finalize⽅法，将其放⼊F-Queue队列，由⼀低优先级线程执⾏该队列中对象的finalize⽅法。执⾏finalize⽅法完毕后，GC会再次判断该对象是否可达，若不可达，则进⾏回收，否则，对象“复活”
每个对象只能触发⼀次finalize()⽅法


#### JVM中那些是线程共享区
![[F$678OZMO7SV`(ZGKCE48WS.jpg]]
线程共享： 堆区， 方法区
线程私有： 栈（分为java虚拟机栈，本地方法栈），程序计数器

#### JVM有那些垃圾回收算法
1. MarkSweep 标记清除算法：这个算法分为两个阶段，标记阶段：把垃圾内存标记出来，清除阶段：直接将垃圾内存回收。这种算法是⽐较简单的，但是有个很严重的问题，就是会产⽣⼤量的内存碎⽚。

2. Copying 拷⻉算法：为了解决标记清除算法的内存碎⽚问题，就产⽣了拷⻉算法。拷⻉算法将内存分为⼤⼩相等的两半，每次只使⽤其中⼀半。垃圾回收时，将当前这⼀块的存活对象全部拷⻉到另⼀半，然后当前这⼀半内存就可以直接清除。这种算法没有内存碎⽚，但是他的问题就在于浪费空间。⽽且，他的效率跟存活对象的个数有关。

3. MarkCompack 标记压缩算法：为了解决拷⻉算法的缺陷，就提出了标记压缩算法。这种算法在标记阶段跟标记清除算法是⼀样的，但是在完成标记之后，不是直接清理垃圾内存，⽽是将存活对象往⼀端移动，然后将端边界以外的所有内存直接清除。


#### 什么是STW？
STW: Stop-The-World，是在垃圾回收算法执⾏过程当中，需要将JVM内存冻结的⼀种状态。在STW状态下，JAVA的所有线程都是停⽌执⾏的-GC线程除外，native⽅法可以执⾏，但是，不能与JVM交互。GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。

#### 线程的生命周期
1. 新建状态，新创建了⼀个线程对象。
2. 就绪状态，线程对象创建后，其他线程调⽤了该对象的start⽅法。该状态的线程位于可运⾏线程池中，变得可运⾏，等待获取CPU的使⽤权。
3. 运行状态，就绪状态的线程获取了CPU，执⾏程序代码。
4. 阻塞状态，阻塞状态是线程因为某种原因放弃CPU使⽤权，暂时停⽌运⾏。直到线程进⼊就绪状态，才有机会转到运⾏状态
5. 死亡状态，线程执⾏完了或者因异常退出了run⽅法，该线程结束⽣命周期。

阻塞的情况⼜分为三种：
1. 等待阻塞：运⾏的线程执⾏wait⽅法，该线程会释放占⽤的所有资源，JVM会把该线程放⼊“等待池”中。进⼊这个状态后，是不能⾃动唤醒的，必须依靠其他线程调⽤notify或notifyAll⽅法才能被唤醒，wait是object类的⽅法
2. 同步阻塞：运⾏的线程在获取对象的同步锁时，若该同步锁被别的线程占⽤，则JVM会把该线程放⼊“锁池”中。
3. 其他阻塞：运⾏的线程执⾏sleep或join⽅法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时、join等待线程终⽌或者超时、或者I/O处理完毕时，线程重新转⼊就绪状态。sleep是Thread类的⽅法

#### 锁池 和 等待池 定义
锁池：所有需要竞争同步锁的线程都会放在锁池当中，⽐如当前对象的锁已经被其中⼀个线程得到，则其他线程需要在这个锁池进⾏等待，当前⾯的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进⼊就绪队列进⾏等待cpu资源分配。

等待池：当我们调⽤wait（）⽅法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调⽤了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出⼀个线程放到锁池，⽽notifyAll()是将等待池的所有线程放到锁池当中

#### sleep()、wait()、join()、yield()之间的的区别
1. sleep 是 Thread 类的静态本地⽅法，wait 则是 Object 类的本地⽅法。

2. sleep⽅法不会释放lock，但是wait会释放，⽽且会加⼊到等待队列中。

**注**：sleep就是把cpu的执⾏资格和执⾏权释放出去，不再运⾏此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运⾏了。⽽如果sleep时该线程有锁，那么sleep不会释放这个锁，⽽是把锁带着进⼊了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说⽆法执⾏程序。如果在睡眠期间其他线程调⽤了这个线程的interrupt⽅法，那么这个线程也会抛出interruptexception异常返回，这点和wait是⼀样的。

3. sleep⽅法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。
4. sleep不需要被唤醒（休眠之后退出阻塞），但是wait需要（若是不指定时间需要被别⼈中断）。
5. sleep ⼀般⽤于当前线程休眠，或者循环暂停操作，wait 则多⽤于多线程之间的通信。
6. sleep 会让出 CPU 执⾏时间且强制上下⽂切换，⽽ wait 则不⼀定，wait 后可能还是有机会重新竞争到锁继续执⾏的。
7. yield（）执⾏后线程直接进⼊就绪状态，⻢上释放了cpu的执⾏权，但是依然保留了cpu的执⾏资格，所以有可能cpu下次进⾏线程调度还会让这个线程获取到执⾏权继续执⾏
8. join（）执⾏后线程进⼊阻塞状态，例如在线程B中调⽤线程A的join（），那线程B会进⼊到阻塞队列，直到线程A结束或中断线程

#### 线程安全的理解
不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问，当多个线程访问⼀个对象时，如果不⽤进⾏额外的同步控制或其他的协调操作，调⽤这个对象的⾏为都可以获得正确的结果，我们就说这个对象是线程安全的。

**堆** ：是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是⽤户分配的空间。堆在操作系统对进程初始化的时候分配，运⾏过程中也可以向系统要额外的堆，但是⽤完了要还给操作系统，要不然就是内存泄漏。在Java中，堆是Java虚拟机所管理的内存中最⼤的⼀块，是所有线程共享的⼀块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯⼀⽬的就是存放对象实例，⼏乎所有的对象实例以及数组都在这⾥分配内存。

**栈** ：是每个线程独有的，保存其运⾏状态和局部⾃动变量的。栈在线程开始的时候初始化，每个线程的栈互相独⽴，因此，栈是线程安全的。操作系统在切换线程的时候会⾃动切换栈。栈空间不需要在⾼级语⾔⾥⾯显式的分配和释放。


#### 守护线程的理解
守护线程：专门为用户线程提供服务的线程，它的生命周期依赖于用户线程。
只要JVM中仍然还存在用户线程正在运行的情况下，守护线程才会有存在的意义。否则，一旦JVM进程结束，那守护线程也会随之结束。
守护线程和用户线程的创建方式是完全相同的，我们只需要调用用户线程里面的setDaemon方法并且设置成true，
**注意**： 由于守护线程的终⽌是⾃身⽆法控制的，因此不能把IO、File等重要操作逻辑分配给它

#### ThreadLocal的底层原理和使用场景
底层原理：
1. ThreadLocal是Java中所提供的线程本地存储机制，可以利⽤该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意⽅法中获取缓存的数据
2. ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值
3. 如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该要把设置的key，value，也就是Entry对象进⾏回收，但线程池中的线程不会回收，⽽线程对象是通过强引⽤指向ThreadLocalMap，ThreadLocalMap也是通过强引⽤指向Entry对象，线程不被回收，Entry对象也就不会被回收，从⽽出现内存泄漏，解决办法是，在使⽤了ThreadLocal对象之后，⼿动调⽤ThreadLocal的remove⽅法，⼿动清除Entry对象
4. ThreadLocal经典的应⽤场景就是连接管理（⼀个线程持有⼀个连接，该连接对象可以在不同的⽅法之间进⾏传递，线程之间不共享同⼀个连接）
![[Pasted image 20220922200753.png]]

使用场景：
1. 在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。
2. 线程间数据隔离
3. 进行事务操作，用于存储线程事务信息
4. 数据库连接，Session会话管理

**注**：Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离

#### 并发，并行，串行
- 并发：允许两个任务彼此干扰，统一时间点，只有一个任务运行，交替执行

- 并行：两个任务在同一时刻互不干扰地同时执行，时间上重叠

- 串行：时间上不可能发生重叠，任务按顺序执行

#### 并发的三大特性，都满足时保证多线程的运行安全
1. 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）
2. 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）
3. 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序

**注：** synchronized关键字同时满⾜以上三种特性，但是volatile关键字不满⾜原⼦性。

#### Java死锁原因和如何避免
原因：
1. ⼀个资源每次只能被⼀个线程使⽤
2. ⼀个线程在阻塞等待某个资源时，不释放已占有资源
3. 一个线程已经获得的资源，在未使用完之前不能被强行剥夺
4. 若⼲线程形成头尾相接的循环等待资源关系

要避免死锁，只需要不满⾜其中某⼀个条件即可。并且要避免死锁就需要打破第4个条件，不出现循环等待锁的关系

开发过程中：
1. 要注意加锁顺序，保证每个线程按同样的顺序进⾏加锁
2. 要注意加锁时限，可以针对锁设置⼀个超时时间
3. 要注意死锁检查，这是⼀种预防机制，确保在第⼀时间发现死锁并进⾏解决


#### synchronized用法和原理
- 用法：synchronized可以修饰静态方法、普通方法、代码块。 能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁

- 原理：底层是采用Java对象头来存储锁信息的,并且还支持锁升级。在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，



#### synchronized 和 volatile 的区别是什么
1. volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
3. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
4. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5. volatile标记的变量不会被编译器优化（禁止指令重排序优化）；synchronized标记的变量可以被编译器优化。（即有序性体现）

#### 使用线程池的意义？解释下线程池参数
意义：
1. 降低资源消耗；提⾼线程利⽤率，降低创建和销毁线程的消耗。
2. 提⾼响应速度；任务来了，直接有线程可⽤可执⾏，⽽不是先创建线程，再执⾏。
3. 提⾼线程的可管理性；线程是稀缺资源，使⽤线程池可以统⼀分配调优监控。

- corePoolSize 代表核⼼线程数，也就是正常情况下创建⼯作的线程数，这些线程创建后并不会消除，⽽是⼀种常驻线程
- maxinumPoolSize 代表的是最⼤线程数，它与核⼼线程数相对应，表示最⼤允许被创建的线程数，⽐如当前任务较多，将核⼼线程数都⽤完了，还⽆法满⾜需求时，此时就会创建新的线程，但是线程池内线程总数不会超过最⼤线程数
- keepAliveTime 、 unit 表示超出核⼼线程数之外的线程的空闲存活时间，也就是核⼼线程不会消除，但是超出核⼼线程数的部分线程如果空闲⼀定的时间则会被消除,我们可以通过setKeepAliveTime 来设置空闲时间
- workQueue ⽤来存放待执⾏的任务，假设我们现在核⼼线程都已被使⽤，还有任务进来则全部放⼊队列，直到整个队列被放满但任务还再持续进⼊则会开始创建新的线程
- ThreadFactory 实际上是⼀个线程⼯⼚，⽤来⽣产线程执⾏任务。我们可以选择使⽤默认的创建⼯⼚，产⽣的线程都在同⼀个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择⾃定义线程⼯⼚，⼀般我们会根据业务来制定不同的线程⼯⼚
- Handler 任务拒绝策略，有两种情况，第⼀种是当我们调⽤ shutdown 等⽅法关闭线程池后，这时候即使线程池内部还有没执⾏完的任务正在执⾏，但是由于线程池已经关闭，我们再继续想线程池提交任务就会遭到拒绝。另⼀种情况就是当达到最⼤线程数，线程池已经没有能⼒继续处理新提交的任务时，这是也就拒绝

#### 线程池处理流程简化版
线程池内部是通过队列+线程实现的。

线程池执行任务，首先查看核心线程是否已满，若未满，则创建核心线程执行；若已满，则查看任务队列是否已满，若未满，则将任务放入队列中；若已满，则查看最大线程数是否达到，若未达到，则创建临时线程执行任务；若已达到，则根据拒绝策略处理任务。
![[3`_49HUASU59B%5FB7))~H1.png]]

#### 线程池中阻塞队列的作⽤？为什么是先添加列队⽽不是先创建最⼤线程？
1. ⼀般的队列只能保证作为⼀个有限⻓度的缓冲区，如果超出了缓冲⻓度，就⽆法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续⼊队的任务。
   阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进⼊wait状态，释放cpu资源。
   阻塞队列⾃带阻塞和唤醒的功能，不需要额外处理，⽆任务执⾏时,线程池利⽤阻塞队列的take⽅法挂起，从⽽维持核⼼线程的存活、不⾄于⼀直占⽤cpu资源
   
2. 在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。

#### 线程池中线程复用原理
线程池将线程和任务进⾏解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的⼀个线程必须对应⼀个任务的限制。
在线程池中，同⼀个线程可以从阻塞队列中不断获取新任务来执⾏，其核⼼原理在于线程池对 Thread进⾏了封装，并不是每次执⾏任务都会调⽤ Thread.start() 来创建新线程，⽽是让每个线程去执⾏⼀个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执⾏，如果有则直接执⾏，也就是调⽤任务中的 run ⽅法，将 run ⽅法当成⼀个普通的⽅法执⾏，通过这种⽅式只使⽤固定的线程就将所有任务的 run ⽅法串联起来。

#### 索引的基本原理
索引的原理：就是把无序的数据变成有序的查询。索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据


#### Mysql索引设计原则
根本目的：查询更快，占用空间更小。
1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
2. 基数较小的表，索引效果较差，没有必要在此列建立索引
3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，  如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进  行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
5. 定义有外键的数据列一定要建立索引。
6. 更新频繁字段不适合创建索引
7. 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
8. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
9. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
10. 对于定义为text、image和bit的数据类型的列不要建立索引。

#### Mysql锁的类型有那些
锁的属性分类：1.共享锁 ，2.排他锁
锁的状态分类：1.意向共享锁，2.意向排它锁
锁的粒度分类：1.行级锁（INNODB默认采用），2.表级锁（INNODB,MYISAM），3.页级锁（BDB引擎），4.记录锁，5.间隙锁，6.临键锁

实际上的锁有：1.行级锁，2.表级锁，3.页级锁，4.记录锁，5.间隙锁，6.临键锁。其余属性和状态只是观察锁的角度不同。

- 共享锁
共享锁又称读锁，简称S锁。当一个事务为数据加上读锁后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放后，其他事务才能对该事务进行添加写锁。
共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。
- 排他锁
排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。
排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。
- 表锁
表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能  进行对表进行访问；
特点： 粒度大，加锁简单，容易冲突；
- 行锁
行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；
特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；
- 记录锁
记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。
精准条件命中，并且命中的条件字段是唯一索引
加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前  被其他事务读取的脏读问题。
- 页锁
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
- 间隙锁
属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空  隙则会形成一个区间，遵循左开右闭原则。
范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复  读)的事务级别中。
触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务  里，A事务的两次查询出的结果会不一样。
比如表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）
- 临键锁
也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一   个区间也会锁住
触发条件：范围查询并命中，查询命中了索引。
结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。

---
如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态  就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是  意向锁。
- 意向共享锁
当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。
- 意向排他锁
当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。

#### Mysql事务的基本特性和隔离级别

事务基本特性ACID，分别是：
1. A.原子性，一个事务中的操作要么全部成功，要么全部失败。
2. C.一致性，数据库总是从一个一致性的状态转移到另外一个一致性的状态。（比如A转钱给B100元，那么A-100 ，B+100）
3. I.隔离性，一个事务的修改在最终提交前，对其他事务是不可见的。
4. D.持久性，一旦事务提交，所做的修改就会永久保存到数据库中。

隔离级别有4类，分别是：
1. read uncommit  读未提交 ，可能会读到其他事务未提交的数据，也叫脏读。
2. read commit  读已提交，这是Orcle的默认级别，即两次读取结果不一致，叫不可重复读。
	不可重复读解决了脏读的问题，他只会读取已经提交的事务。
3. repeatable read  可重复读，这是mysql的默认级别，即每次读取结果都一样，但是可能产生幻读（读取到了别的事务插入的数据，导致前后读取不一样）。
4. serializable  序列化，事务按顺序执行。一般不使用，他会给每一行读取的数据加锁，导致大量超时和锁竞争的问题。
	可避免脏读、不可重复读、幻读。
	
#### ACID靠什么保证
1. 原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
2. 一致性由其他三大特性保证、程序代码要保证业务上的一致性
3. 隔离性由MVCC来保证
4. 持久性由 内存 + redo log来保证，mysql修改数据同时在内存和redo lgo记录这次操作，宕机的时候可以从redo log恢复。


#### 什么是MVCC
多版本并发控制：读取数据时通过⼀种类似快照的⽅式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到⾃⼰特定版本的数据和版本链。
MVCC只在 READ COMMITTED（读已提交） 和REPEATABLE READ （可重复读）两个隔离级别下工作。其他两个隔离级别和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView，
而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。



#### 动态代理是什么，有哪些应用
定义：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。

应用：Spring的AOP

#### Spring是什么
Spring是⼀个轻量级的控制反转（IoC)和⾯向切⾯（AOP）的容器框架：
1. 从⼤⼩与开销两⽅⾯⽽⾔Spring都是轻量级的。
2. 通过控制反转(IoC)的技术达到松耦合的⽬的
3. 提供了⾯向切⾯编程的丰富⽀持，允许通过分离应⽤的业务逻辑与系统级服务进⾏内聚性的开发
4. 包含并管理应⽤对象(Bean)的配置和⽣命周期，这个意义上是⼀个容器。
5. 将简单的组件配置、组合成为复杂的应⽤，这个意义上是⼀个框架。


#### 谈谈你对AOP的理解
系统是由许多不同的组件所组成的，每⼀个组件各负责⼀块特定功能。除了实现⾃身核⼼功能之外，这些组件还经常承担着额外的职责。例如⽇志、事务管理和安全这样的核⼼服务经常融⼊到⾃身具有核⼼ 业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。 

当我们需要为分散的对象引⼊公共⾏为的时候，OOP则显得⽆能为⼒。也就是说，OOP允许你定义从上 到下的关系，但并不适合定义从左到右的关系。例如⽇志功能。 
⽇志代码往往⽔平地散布在所有对象层次中，⽽与它所散布到的对象的核⼼功能毫⽆关系。
在OOP设计中，它导致了⼤量代码的重复，⽽不利于各个模块的重⽤。

AOP：将程序中的交叉业务逻辑（⽐如安全，⽇志，事务等），封装成⼀个切⾯，然后注⼊到⽬标对象 （具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进⾏增强，⽐如对象中的⽅法进⾏增 强，可以在执⾏某个⽅法之前额外的做⼀些事情，在某个⽅法执⾏之后额外的做⼀些事情

#### IOC的理解
容器概念、控制反转、依赖注⼊

ioc容器：实际上就是个map（key，value），⾥⾯存的是各种对象（在xml⾥配置的bean节点、 @repository、@service、@controller、@component），在项⽬启动的时候会读取配置⽂件⾥⾯的 bean节点，根据全限定类名使⽤反射创建对象放到map⾥、扫描到打上上述注解的类还是通过反射创建 对象放到map⾥。 
这个时候map⾥就有各种对象了，接下来我们在代码⾥需要⽤到⾥⾯的对象时，再通过DI注⼊ （autowired、resource等注解，xml⾥bean节点内的ref属性，项⽬启动的时候会读取xml节点ref属性 根据id注⼊，也会扫描这些注解，根据类型或id注⼊；id就是对象名）。 

控制反转： 没有引⼊IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运⾏到某⼀点的时候，⾃⼰必须 主动去创建对象B或者使⽤已经创建的对象B。⽆论是创建还是使⽤对象B，控制权都在⾃⼰⼿上。 
引⼊IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运⾏到需要对象B的时候，IOC容器会 主动创建⼀个对象B注⼊到对象A需要的地⽅。 通过前后的对⽐，不难看出来：对象A获得依赖对象B的过程,由主动⾏为变为了被动⾏为，控制权颠倒 过来了，这就是“控制反转”这个名称的由来。 
全部对象的控制权全部上缴给“第三⽅”IOC容器，所以，IOC容器成了整个系统的关键核⼼，它起到了 ⼀种类似“粘合剂”的作⽤，把系统中的所有对象粘合在⼀起发挥作⽤，如果没有这个“粘合剂”，对象与 对象之间会彼此失去联系，这就是有⼈把IOC容器⽐喻成“粘合剂”的由来。 

依赖注⼊： “获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由⾃身管理变为了由IOC容器 主动注⼊。依赖注⼊是实现IOC的⽅法，就是由IOC容器在运⾏期间，动态地将某种依赖关系注⼊到对象 之中

#### Spring Boot、Spring MVC 和 Spring 有什么区别
spring是⼀个IOC容器，⽤来管理Bean，使⽤依赖注⼊实现控制反转，可以很⽅便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更⽅便将不同类不同⽅法中的共同处理抽取成切⾯、⾃动注⼊给⽅法执⾏，⽐如⽇志、异常等

springmvc是spring对web框架的⼀个解决⽅案，提供了⼀个总的前端控制器Servlet，⽤来接收请求，然后定义了⼀套路由策略（url到handle的映射）及适配执⾏handle，将handle结果使⽤视图解析技术⽣成视图展现给前端

springboot是spring提供的⼀个快速开发⼯具包，让程序员能更⽅便、更快速的开发spring+springmvc应⽤，简化了配置（约定了默认配置），整合了⼀系列的解决⽅案（starter机制）、redis、mongodb、es，可以开箱即⽤


#### Mybatis 的插件运行原理
插件的运行是基于 JDK 动态代理 + 拦截器链实现。
Mybatis 只支持针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这4 种接口的插件， Mybatis 使用 JDK 的动态代理， 为需要拦截的接口生成代理对象以实现接口方法拦截功能， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的invoke() 方法， 拦截那些你指定需要拦截的方法。

#### Mybatis的优缺点
优点：

1. 基于 SQL 语句编程，相当灵活，不会对应⽤程序或者数据库的现有设计造成任何影响，SQL 写在XML ⾥，解除 sql 与程序代码的耦合，便于统⼀管理；提供 XML 标签， ⽀持编写动态 SQL 语句， 并可重⽤。

2. 与 JDBC 相⽐，减少了 50%以上的代码量，消除了 JDBC ⼤量冗余的代码，不需要⼿动开关连接；

3. 很好的与各种数据库兼容（因为 MyBatis 使⽤ JDBC 来连接数据库，所以只要JDBC ⽀持的数据库 MyBatis 都⽀持）。

4. 能够与 Spring 很好的集成；

5. 提供映射标签， ⽀持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， ⽀持对象关系组件维护。

缺点：

1. SQL 语句的编写⼯作量较⼤， 尤其当字段多、关联表多时， 对开发⼈员编写SQL 语句的功底有⼀定要求。

2. SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。

#### Mybatis #{}和${}的区别是什么
1. #{}是预编译处理、是占位符， ${}是字符串替换、是拼接符。
2. 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值；在处理\${}时， 就是把${}替换成变量的值，调用 Statement 来赋值；
3. #{} 的变量替换是在DBMS 中、变量替换后，#{} 对应的变量自动加上单引号 ;  \${}的变量替换是在 DBMS 外、变量替换后，${} 对应的变量不会加上单引号
4. 使用#{}可以有效的防止 SQL 注入， 提高系统安全性。

#### Redis单线程快的原因
1. 纯内存操作
2. 核心是基于非阻塞的IO多路复用机制
3. 单线程反而避免了多线程的频繁上下文切换带来的性能问题


#### 雪花算法原理
第⼀位符号位固定为0，41位时间戳，10位workId，12位序列号，位数可以有不同实现。

优点：每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。时间戳值在⾼位，中间是固定的机器码，⾃增的序列在低位，整个ID是趋势递增的。能够根据业务场景数据库节点布置灵活调整bit位划分，灵活度⾼
。
缺点：强依赖于机器时钟，如果时钟回拨，会导致重复的ID⽣成，所以⼀般基于此的算法发现时钟回拨，都会抛异常处理，阻⽌ID⽣成，这可能导致服务不可⽤。
