**描述**

政府在某山区修建了一条道路，恰好穿越总共m个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为di(为正整数)，其中，0<i<m。为了提高山区的文化素质，政府又决定从m个村中选择n个村建小学(设0<n≤m<500)。请根据给定的m、n以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。

**输入**

第1行为m和n，其间用空格间隔

第2行为m−1 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。

例如:

10 3
2 4 6 5 2 4 3 1 3

表示在10个村庄建3所学校。第1个村庄与第2个村庄距离为2，第2个村庄与第3个村庄距离为4，第3个村庄与第4个村庄距离为6，...，第9个村庄到第10个村庄的距离为3。

**输出**

各村庄到最近学校的距离之和的最小值。

**样例输入**

10 2
3 1 3 1 1 1 1 1 3

**样例输出**

18

```c++
#include <bits/stdc++.h>
#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef unsigned long long ull;
typedef long long LL;
const int MOD = 1e9+7;
const int INF = 0x3f3f3f3f;
const int N =1e4+30;
int m,n; 
int f[502]; //存储村庄数轴位置(前缀和)
int dp[502][502]; //dp[i][j],在前i所村庄,建j个学校的最小距离和
int cost[502][502]; //cost[i][j] ,在i到j这些村庄中建造一所小学，各村庄的路程和 
/*
思路：1.前缀和各村庄位置，得到 f[i]数轴位置
	  2.预处理各村庄间修建1所学校的花费，即cost[i][j]。 
	  3.令（i=[1,m]）dp[i][1]=cost[1][i]; 得到最小边界值。 
	  4.得到前i个村庄修建j个学校的关系表达式，dp[i][j]=min(dp[i][j],dp[k][j-1]+cost[k+1][i]); 
*/
int main()
{
	IO;
	cin>>m>>n;
	//第一个村庄默认位置为0，下标从1-m排列 
	for(int i=2;i<=m;++i)
	{
		cin>>f[i];
		f[i]+=f[i-1];
	}
	
	//预处理建一所小学，各村庄的花费 
	for(int i=1;i<=m;++i)
	{
		for(int j=i;j<=m;++j)
		{
			//1.在i~j村庄的中心点建学校，会使得i~j村庄到最近小学的路程最小，即位置：(i+j)/2 
			/*
				2.尽管中心村庄位置在不断右移，但是相对应的cost[i][j-1]的村庄距离和是不变的
				即：3 4 7 8  ===> 3 4 7 8 9
				由中心点f[2]=4 变成  f[3]=7，两点的相邻关系，由本来f[3]去f[2]所修的学校，
				变成了由f[2]去f[3]所修学校,路程花费一样。 
			*/
			//3.f[j]-f[(i+j)/2]，即新加入的村庄点距离中心村庄建学校的距离差。 
			cost[i][j]=cost[i][j-1]+f[j]-f[(i+j)/2];
		}
	}
	//初始化无穷大，方便后续求最小值 
	memset(dp,0x3f,sizeof(dp));
	
	//赋值，前i个村庄建1个学校的距离最小值 ，即初始条件 
	for(int i=1;i<=m;++i)dp[i][1]=cost[1][i];
	
	//区间枚举 
	for(int i=1;i<=m;++i) //前i个村庄 
	{
		for(int j=1;j<=n;++j) //建j个小学 
		{
			//修建小学大于村庄数，(即每个村庄修建小学，自己到自己的距离即为0，则累计为0) 
			if(j>i)
			{
				dp[i][j]=0;
				continue;
			}
			for(int k=1;k<i;++k) //枚举1~k村庄 
			{
				/*
					dp[k][j-1] ,左半区域，1~k村庄修建j-1个学校的最小距离和 
					cost[k+1][i] ,右半区域, k+1~i个村庄，修建1个学校的最小距离和 
					因此，dp[i][j]=dp[k][j-1] + cost[k+1][i] .
				*/ 
				dp[i][j]=min(dp[i][j],dp[k][j-1]+cost[k+1][i]);
			}
		}
	}
	
	cout<<dp[m][n];
}
 
```

