**描述**

一年一度的“跳石头”比赛又要开始了!

这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 N块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。

**输入**

第一行包含三个整数 L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证L≥1 且N≥M≥0。

接下来 N 行，每行一个整数，第 i 行的整数Di(0<Di<L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。

**输出**

一个整数，即最短跳跃距离的最大值。

**样例输入**

25 5 2 
2
11
14
17 
21

**样例输出**

4

**提示**

输入输出样例 1 说明：将与起点距离为 2和14 的两个岩石移走后,最短的跳跃距离为 4(从与起点距离17的岩石跳到距离 21 的岩石,或者从距离21 的岩石跳到终点)。

另：对于20%的数据,0≤M≤N≤10。

对于50%的数据,0≤M≤N≤100。

对于100%的数据,0≤M≤N≤50,000,1≤L≤1,000,000,000。



```c++
#include <bits/stdc++.h>
#define LL long long
#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
const int INF=0x3f3f3f3f;
const int MOD=9901;
const int N=5e4+5;
int dis[N];
int L,n,m;
/*
	思路：二分枚举.二分题，它让你求啥，你就二分啥。 
	如果当前石头与上一块石头的距离小于枚举的答案，
	那么说明当前石头需要被移走，依次反复，
	如果到达终点的时候所移走的石头不超过M块，
	那么说明当前枚举的答案可行，但是需要继续增加距离，
	因为可能还不是最长的，否则就减小距离。
*/
bool isOk(int x)
{
	int cnt=0; //移动石头个数 
	int move=0; //上一跳位置 
	for(int i=1;i<=n;++i)
	{
		//如果从move到当前位置所用的距离并不够，就把这个石头移走，判断下一个石头，直到可以满足 
		if(dis[i]-dis[move]<x)
		{
			cnt++;	
		}	
		else move=i;
	} 
	//最后判断跳x距离，用的石头有没有超出限制 
	if(cnt<=m)return true;
	else return false;
}
int main()
{
	IO;
	
	cin>>L>>n>>m;
	//dis[0]起点，dis[n+1]终点 
	for(int i=1;i<=n;++i)
	{
		cin>>dis[i];
	}
	dis[n+1]=L; 
	
	//二分枚举最长的最短跳跃距离 
	int l=1,r=L,mid; 
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(isOk(mid)) //满足跳跃条件，扩大距离 
		{
			l=mid+1;
		} 
		else //不满足跳跃条件，缩小距离 
		{
			r=mid-1;
		}
	}
	cout<<l-1;
}
```

