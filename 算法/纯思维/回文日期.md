**描述**

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用8位数字表示一个日期，其中，前4位代表年份，接下来2位代表月 份，最后2位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。

一个8位数字是回文的，当且仅当对于所有的i(1≤i≤8)从左向右数的第i个数字和第9−i个数字（即从右向左数的第i个数字）是相同的。

例如：

•对于2016年11月19日，用8位数字20161119表示，它不是回文的。

•对于2010年1月2日，用8位数字20100102表示，它是回文的。

•对于2010年10月2日，用8位数字20101002表示，它不是回文的。

每一年中都有12个月份：

其中，1,3,5,7,8,10,12月每个月有31天；4,6,9,11月每个月有30天；而对于2月，闰年时有29天，平年时有28天。

一个年份是闰年当且仅当它满足下列两种情况其中的一种：

1.这个年份是4的整数倍，但不是100的整数倍；

2.这个年份是400的整数倍。

例如：

•以下几个年份都是闰年：2000,2012,2016。

•以下几个年份是平年：1900,2011,2014。

**输入**

两行，每行包括一个8位数字。

第一行表示牛牛指定的起始日期。

第二行表示牛牛指定的终止日期。

保证datei和都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。

保证date1 —定不晚于date2。

**输出**

一个整数，表示在date1和date2之间，有多少个日期是回文的。

**样例输入**

20110101
20111231

**样例输出**

 1



### 思路： ### 

通过枚举右半部分，月和日，反向得出年份。需要注意的就是二月闰年的一个判断，我们会发现0229存在回文的年份9220恰好就是闰年，对此对于2月的天数都枚举为29。 最后只需要判断年月日的总和是否在2个date的范围内即可。



### 参考代码： ###

```c++
#include <bits/stdc++.h>
#define io ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define LL long long
#define PII pair<int,int>
#define PSS pair<string,string>
#define x first
#define y second
using namespace std;
typedef unsigned long long ull;
const int INF=0x3f3f3f3f;
const int N=1e6+7;
const int M=6100;
const int mod=1e9+7;
 
int m[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int main()
{
	io;
 	int l,r,cnt=0;
 	cin>>l>>r;
 	
 	 
 	for(int i=1,q,sum;i<=12;i++) //月 
 	{
 		for(int j=1;j<=m[i];j++) //日
		{
		 	q=j%10*1000+j/10*100+i%10*10+i/10;
		 	sum=q*10000+i*100+j;
		 	if(sum>=l && sum<=r)cnt++;
		} 
	 }
	cout<<cnt;
}
/*
20000101
20100123
*/
```

