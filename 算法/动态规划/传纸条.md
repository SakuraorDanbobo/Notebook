#### 描述
小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。



在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。



还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。


【限制】

30%的数据满足：1<=m,n<=10

100%的数据满足：1<=m,n<=50



#### 输入

输入的第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1<=m,n<=50）。



接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。



#### 输出

输出共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

#### 样例输入

3 3
0 3 9
2 8 5
5 7 0


#### 样例输出

34

#### 思路
```in
尽管题意求的是左上到右下的一条路和右下到左上一条路,这2条不相交的路径上的最大和。但是我们可以看作2人从起点同时出发，沿2个不同方向同时向右下角出发。

第一种写法,暴力四重枚举 O(n^4)
	状态定义：dp[i][j][k][l] ,(i,j)代表第一个人走的位置,
	(k,l)代表第二个人走的位置，2人走的最大值答案之和 
	我们知道(i,j)可以从(i-1,j),(i,j-1)转移,同理得(k,l).
	因此状态转移:
	dp[i][j][k][l]=max(dp[i-1][j][k-1][l],dp[i][j-1][k][l-1]
	,dp[i-1][j][k][l-1],dp[i][j-1][k-1][l])+f[i][j]+f[k][l]; 
	因为路径不重叠，因此当2点不重合时我们加上f[k][l]的一个值 

第二种，我们可以在四维的基础上进行优化，将其转化为3维dp。
 因为两人同时进行，步数是相同的，因此，我们状态定义：
 dp[k][i][j]，表示（行与列的和）k，一个人走到了i行，另一个人走到了j行的最大值之和

 那么我们如何得到每个人的列呢？设yi 和  yj 分别为2人的列坐标
 则 yi+i=k ,yj+j=k ，即 yi=k-i , yj=k-j 。
 我们每次是从(1,1)到（m,n）点那么 k 的范围就应该是 [2,m+n];
 那么 i 的范围呢？ 由 行 1<= i <= m &&  列 1<=k-i<=n ，
 得到 max(1,k-n)<= i <= min(k-1,m) 。另外一人同理得

 又因为我们的方向只能向右和向下，
 得到两条路线的4个方向：{右右，右下,下右，下下}，因此得到我们的状态转移方程：
 dp[k][i][j]=max(dp[k-1][i][j],dp[k-1][i-1][j],dp[k-1][i][j-1],dp[k-1][i-1][j-1])+f[i][yi]+f[j][yj]
 因为路径不重叠，因此当2点不重合时我们加上f[j][yj]的一个值 

```

#### 参考代码
```c++
#include <bits/stdc++.h>
#define io ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
#define LL long long
#define PII pair<int, int>
#define PIII pair<int, PII>
#define PSI pair<string, int>
#define PIIS pair<int, pair<int, string>>
#define PDD pair<double, double>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 2e5 + 5;
const int M = 1e6;
const int mod = 1e9 + 7;
const int add = 1e6;

int m,n;
int f[55][55];
/*
	思路：尽管题意求的是左上到右下的一条路和右下到左上一条路,这2条不相交
	的路径上的最大和。但是我们可以看作2人从起点同时出发，沿2个不同方向同
	时向右下角出发。
*/

//暴力四重枚举 O(n^4)
/*
	状态定义：dp[i][j][k][l] ,(i,j)代表第一个人走的位置,
	(k,l)代表第二个人走的位置，2人走的最大值答案之和 
	
	我们知道(i,j)可以从(i-1,j),(i,j-1)转移,同理得(k,l).
	因此状态转移:
	dp[i][j][k][l]=max(dp[i-1][j][k-1][l],dp[i][j-1][k][l-1]
	,dp[i-1][j][k][l-1],dp[i][j-1][k-1][l])+f[i][j]+f[k][l]; 
	因为路径不重叠，因此当2点不重合时我们加上f[k][l]的一个值 
*/ 
int dp[55][55][55][55];
void solve1()
{
	//第一个人的横坐标和纵坐标 i 和 j 
	//第二个人的横坐标和纵坐标 k 和 l 
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=m;k++)
				for(int l=1;l<=n;l++)
				{
					int a=max(dp[i-1][j][k-1][l],dp[i][j-1][k][l-1]);
					 int b=max(dp[i-1][j][k][l-1],dp[i][j-1][k-1][l]);
					 dp[i][j][k][l]=max(a,b)+f[i][j];
					 if(i!=k && j!=l)
					 {
					 	dp[i][j][k][l]+=f[k][l];
					}
				}
					 
	cout<<dp[m][n][m][n]; 
}

//优化  O(n^3)
/*
 我们可以在四维的基础上进行优化，将其转化为3维dp。
 因为两人同时进行，步数是相同的，因此，我们状态定义：
 dp[k][i][j]，表示（行与列的和）k，一个人走到了i行，另一个人走到了j行的最大值之和

 那么我们如何得到每个人的列呢？设yi 和  yj 分别为2人的列坐标
 则 yi+i=k ,yj+j=k ，即 yi=k-i , yj=k-j 。
 我们每次是从(1,1)到（m,n）点那么 k 的范围就应该是 [2,m+n];
 那么 i 的范围呢？ 由 行 1<= i <= m &&  列 1<=k-i<=n ，
 得到 max(1,k-n)<= i <= min(k-1,m) 。另外一人同理得

 又因为我们的方向只能向右和向下，
 得到两条路线的4个方向：{右右，右下,下右，下下}，因此得到我们的状态转移方程：
 dp[k][i][j]=max(dp[k-1][i][j],dp[k-1][i-1][j],dp[k-1][i][j-1],dp[k-1][i-1][j-1])+f[i][yi]+f[j][yj]
 因为路径不重叠，因此当2点不重合时我们加上f[j][yj]的一个值 
*/
int dp1[111][55][55];
void solve2()
{
	for(int k=2;k<=m+n;k++)
	{
		for(int i=max(1,k-n);i<=min(k-1,m);i++)
		{
			for(int j=max(1,k-n);j<=min(k-1,m);j++)
			{
				//右右，右下
				int a=max(dp1[k-1][i][j],dp1[k-1][i-1][j]);
				//下右，下下
				int b=max(dp1[k-1][i][j-1],dp1[k-1][i-1][j-1]);
				dp1[k][i][j]=max(a,b)+f[i][k-i];
				if(i!=j)dp1[k][i][j]+=f[j][k-j];
			}
		}
	}
	cout<<dp1[m+n][m][m]<<"\n";
}
int main()
{
	
	cin>>m>>n;
	
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)cin>>f[i][j];
	}
	// solve1();
	solve2();
	
} 
```