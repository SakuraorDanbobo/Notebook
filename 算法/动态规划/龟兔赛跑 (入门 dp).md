#### Problem Description
据说在很久很久以前，可怜的兔子经历了人生中最大的打击——赛跑输给乌龟后，心中郁闷，发誓要报仇雪恨，于是躲进了杭州下沙某农业园卧薪尝胆潜心修炼，终于练成了绝技，能够毫不休息得以恒定的速度(VR m/s)一直跑。兔子一直想找机会好好得教训一下乌龟，以雪前耻。 最近正值HDU举办50周年校庆，社会各大名流齐聚下沙，兔子也趁此机会向乌龟发起挑战。虽然乌龟深知获胜希望不大，不过迫于舆论压力，只能接受挑战。 比赛是设在一条笔直的道路上，长度为L米，规则很简单，谁先到达终点谁就算获胜。 无奈乌龟自从上次获胜以后，成了名龟，被一些八卦杂志称为“动物界的刘翔”，广告不断，手头也有了不少积蓄。为了能够再赢兔子，乌龟不惜花下血本买了最先进的武器——“"小飞鸽"牌电动车。这辆车在有电的情况下能够以VT1 m/s的速度“飞驰”，可惜电池容量有限，每次充满电最多只能行驶C米的距离，以后就只能用脚来蹬了，乌龟用脚蹬时的速度为VT2 m/s。更过分的是，乌龟竟然在跑道上修建了很多很多（N个)的供电站，供自己给电动车充电。其中，每次充电需要花费T秒钟的时间。当然，乌龟经过一个充电站的时候可以选择去或不去充电。 比赛马上开始了，兔子和带着充满电的电动车的乌龟并列站在起跑线上。你的任务就是写个程序，判断乌龟用最佳的方案进军时，能不能赢了一直以恒定速度奔跑的兔子。
#### Input
本题目包含多组测试，请处理到文件结束。每个测试包括四行： 第一行是一个整数L代表跑道的总长度 第二行包含三个整数N，C，T，分别表示充电站的个数，电动车冲满电以后能行驶的距离以及每次充电所需要的时间 第三行也是三个整数VR，VT1，VT2，分别表示兔子跑步的速度，乌龟开电动车的速度，乌龟脚蹬电动车的速度 第四行包含了N(N<=100)个整数p1,p2...pn,分别表示各个充电站离跑道起点的距离，其中0<p1<p2<...<pn<L 其中每个数都在32位整型范围之内。
#### Output
当乌龟有可能赢的时候输出一行 “What a pity rabbit!"。否则输出一行"Good job,rabbit!"; 题目数据保证不会出现乌龟和兔子同时到达的情况。
#### Sample Input
100
3 20 5
5 8 2
10 40 60
100
3 60 5
5 8 2
10 40 60
#### Sample Output
Good job,rabbit!
What a pity rabbit!

#### 思路
```in
	首先我们状态定义定义为：dp[i] , 到达第i个充电站的最小时间花费。
    我们可以处理0点为我们的起点 ， i+1点为我们的终点。
    当我们枚举第i个充电站的最短距离时，我们一定是从前0~i-1个点枚举得到的最小时间花费。
    我们定义 t 为j点到i点的花费时间，再加上 到达j点的最小时间花费 dp[j]，
    那么我们可以得到状态转移方程： dp[i]=min(dp[j]+t) , (j 为 [0,i-1]范围 )

    其次，有个地方需要注意，就是第i个充电站充电和不充电的选择，一开始想的是dp[i][2]这个
    定义，但是发现，因为起点开始默认是已经充满电了，所以在第0个充电站不用充电，而每一次计
    算从j到i默认的是在j充满电后出发到i，其过程中是不充电的。而我们每次从j点出发，都是默认
    充满电，且时间都是t秒，此时第j+1是没有选择充电的，下一次j迭代加1就会选择充电，然后加上
    前面更新的最优解dp[j]，表示得到选择第j+1个充电站充电方案所用时间的最优解。
```

#### 参考代码
```c++
#include <bits/stdc++.h>
#define io ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
#define LL long long
#define PII pair<int, int>
#define PIII pair<int, PII>
#define PSI pair<string, int>
#define PIIS pair<int, pair<int, string>>
#define PDD pair<double, double>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5 + 5;
const int M = 1e6;
const int mod = 1e9 + 7;
const int add = 1e6;

 
double dp[111]; //到达第i个点的最短时间
int p[111]; //第i个点的距离
int main()
{
    // io;
     int L,n,c,T,vr,vt1,vt2;

     while(cin>>L)
     {
        cin>>n>>c>>T;
        cin>>vr>>vt1>>vt2;
        for(int i=1;i<=n;i++)
        {
            cin>>p[i];
        }
        //预处理起点和终点，
        p[0]=0;
        p[n+1]=L;

        dp[0]=0;
        double t;
         
        for(int i=1;i<=n+1;i++)
        {
            //寻找前i-1个点出发到达i点的最短用时
            double minc=INF;
            for(int j=0;j<i;j++)
            {
                //两充电桩位置
                int d=p[i]-p[j];
                //2点距离差大于满电骑行距离
                if(d>c)
                {
                    t=c*1.0/vt1+(d-c)*1.0/vt2;
                }
                //满电骑行距离大于2点距离
                else t=d*1.0/vt1;

                //加上之前到达j充电站的时间
                t+=dp[j];

                //加上每个点充电的花费时间，起点除外，因为已经充满电了
                if(j>0)t+=T;

                minc=min(minc,t);
            }
            dp[i]=minc;
        }

        if(L*1.0/vr>dp[n+1])cout<<"What a pity rabbit!\n";
        else cout<<"Good job,rabbit!\n";
     }
    // system("pause");
    return 0;
}
/*

*/
```