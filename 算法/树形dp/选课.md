描述

学校实行学分制。每门的必修课都有固定的学分，同时还必须获得相应的选修课程学分。学校开设了 N(N≤300) 门的选修课程，每个学生可选课程的数量 M 是给定的。学生选修了这 M 门课并考核通过就能获得相应的学分。
在选修课程中，有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其他的一些课程的基础上才能选修。例如《Windows程序设计》必须在选修了《Windows操作基础》之后才能选修。我们称《Windows操作基础》是《Windows程序设计》的先修课。每门课的直接先修课最多只有一门。两门课可能存在相同的先修课。
你的任务是为自己确定一个选课方案，使得你能得到的学分最多，并且必须满足先修条件。假定课程之间不存在时间上的冲突。

输入

输入文件的第一行包括两个整数N、M（中间用一个空格隔开）其中1≤N≤300,1≤M≤N。 
以下N行每行代表一门课。课号依次为1，2，…，N。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为0），第二个数为这门课的学分。学分是不超过10的正整数。  

输出

输出只有一个数，实际所选课程的学分总数。

样例输入

7 4
2 2
0 1
0 4
2 1
7 1
7 6
2 2


样例输出

13

 ```
 经典树形DP问题， f[i][j]表示当前在i节点，并且当前已经选的课数量是j，的最大学分数量
 难点在于对dfs的理解，这里处理到每一层的时候，直接对每一个子节点进行递归，但实际求解是
 一个回溯的过程，分组背包的方式也与经典分组背包不同，这里基于闫氏dp的思想，以集合为概念，
 就可以将每组子节点分开来求了，用每一组子节点的每一个状态来处理当前节点每一种选课不同数量
 集合的方式。这里有一些小点，我们新建虚拟节点0，其学分为0，这样可以将森林转化为树，
 然后在一个dfs里面处理完毕，同时选了一个学分为0点空节点，我们的总选课上限也要加一，
 在后面的便利过程中，每一次处理完当前节点的左右子节点后，需要在for外面将自己本身加上，
 保证了数据的完整性，在题目所有的循环中，要注意0这个边界，当当前节点的选课数量为0时是没
 有意义的，所以需要初始化为0，但是其本身就是0，所以这里直接不循环即可，
 
 ```



```java
import java.util.*;
public class Main
{
    static Scanner sz=new Scanner(System.in);
    static List<Integer> ma[];
    static int d[],dp[][];
    static int n,m;
    public static void main(String []args) throws Exception
    {
         n=sz.nextInt();
         m=sz.nextInt();
         ma=new ArrayList[n+1];
         d=new int[n+1];
         //dp[i][j],在i节点选择j门课程的最大学分
         dp=new int[n+1][m+2];
         for(int i=0;i<=n;i++)ma[i]=new ArrayList<>();
         for(int i=1;i<=n;i++)
         {
             int pid=sz.nextInt();
             d[i]=sz.nextInt();
             ma[pid].add(i);
         }
         //从0号点开始，相当于在选的m门课中加了一门第0门课程，因此m+1
         m++;
        solve(0);
        System.out.println(dp[0][m]);
    }

    //本质上树上分组背包
    private static void solve(int p)
    {
        //1.首先枚举物品组
        for(Integer next: ma[p])
        {
            solve(next);

            //2.从大到小循环体积
            for(int i=m-1;i>=0;i--)
            {
                //3.循环决策
                for(int j=1;j<=i;j++)
                {
                    dp[p][i]=Math.max(dp[p][i],dp[p][i-j]+dp[next][j]);
                }
            }
        }
        for(int i=m;i>0;i--)
        {
            dp[p][i]=dp[p][i-1]+d[p];
        }
    }
}
/*

*/
```

